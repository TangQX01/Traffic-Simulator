// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace SIP.FastVRTools.Cameras
{
	[RequireComponent (typeof(CharacterDriver))]
	public class FirstPersonCamera : CameraBase
	{
		private CharacterDriver m_characterDriver;

		/// <summary>
		/// The sensitivity of moving on PC.
		/// </summary>
		public float m_pcMoveScale = 50.0f;

		/// <summary>
		/// The sensitivity of mouse on PC.
		/// </summary>
		public float m_pcRotateScale = 100.0f;

		public float m_mobileMoveScale = 50.0f;

		public float m_mobileRotateScale = 100.0f;

		/// <summary>
		/// The minimun value of X
		/// </summary>
		public float m_minimumX = -360F;

		/// <summary>
		/// The maximun value of X
		/// </summary>
		public float m_maximumX = 360F;

		/// <summary>
		/// The minimun value of Y
		/// </summary>
		public float m_minimumY = -60F;

		/// <summary>
		/// The maximun value of Y
		/// </summary>
		public float m_maximumY = 60F;

		/// <summary>
		/// Moving direction Vector
		/// </summary>
		public Vector3 m_directionVector = Vector3.zero;

		/// <summary>
		/// Rotation Vector
		/// </summary>
		Vector3 m_rotateVector = Vector3.zero;

		/// <summary>
		/// Set to upate by joystick on PC Mode
		/// </summary>
		public bool m_isUpdateByJoystick = false;

        /// <summary>
        /// The Screen joystick for movement.
        /// </summary>
        public ScreenJoyStick m_moveJoyStick;

        /// <summary>
        /// The Screen joystick for rotation.
        /// </summary>
        public ScreenJoyStick m_rotateJoyStick;

        public void Awake()
		{
			m_camType = CamType.FirstPerson;
			m_characterDriver = transform.GetComponent<CharacterDriver>();
		}

		public void Start()
		{
			Init();
		}

		public void Update()
		{
			CameraUpdate();
		}

		public override void CameraUpdate ()
		{
			base.CameraUpdate();
			#region Update Direction Vector
#if UNITY_IPHONE || UNITY_ANDROID
			if(m_moveJoyStick)
			{
				m_directionVector = new Vector3(m_moveJoyStick.m_position.x, 0, m_moveJoyStick.m_position.y);
			}
#else
			if(m_moveJoyStick && m_isUpdateByJoystick)
			{
				m_directionVector = new Vector3(m_moveJoyStick.m_position.x, 0, m_moveJoyStick.m_position.y);
			}
			else
			{
				m_directionVector = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
			}
#endif

			m_characterDriver.m_inputJump = Input.GetButton("Jump");

			//Deal with raw direction vector by keyboard.
			if(m_directionVector != Vector3.zero)
			{
				// Get the length of the directon vector and then normalize it
				// Dividing by the length is cheaper than normalizing when we already have the length anyway
				float directionLength = m_directionVector.magnitude;
				m_directionVector = m_directionVector / directionLength;
				
				// Make sure the length is no bigger than 1
				directionLength = Mathf.Min(1, directionLength);
				
				// Make the input vector more sensitive towards the extremes and less sensitive in the middle
				// This makes it easier to control slow speeds when using analog sticks
				directionLength = directionLength * directionLength;

#if UNITY_IPHONE || UNITY_ANDROID
				// Multiply the normalized direction vector by the modified length
				m_directionVector = m_directionVector * directionLength * m_mobileMoveScale * m_camForwardSpeed * Time.deltaTime;
#else
				m_directionVector = m_directionVector * directionLength * m_pcMoveScale * m_camForwardSpeed * Time.deltaTime;
#endif
			}
			#endregion

			#region Update Rotate Vector

			//Check if the Mouse it out of screen
			//Note: the mouse action on x direction is y axis on the model.
			Rect screenRect = new Rect(0, 0, Screen.width, Screen.height);
			if(screenRect.Contains(Input.mousePosition))
			{
#if UNITY_IPHONE || UNITY_ANDROID
				if(m_rotateJoyStick)
				{
					m_rotateVector.y = transform.localEulerAngles.y + m_rotateJoyStick.m_position.x * m_mobileRotateScale * m_camRotateSpeed * Time.deltaTime;
					m_rotateVector.x += m_rotateJoyStick.m_position.y * m_mobileRotateScale * m_camRotateSpeed * Time.deltaTime;
					m_rotateVector.x = Mathf.Clamp (m_rotateVector.x, m_minimumY, m_maximumY);
				}
#else
				if(m_isUpdateByJoystick)
				{
					if(m_rotateJoyStick)
					{
						m_rotateVector.y = transform.localEulerAngles.y + m_rotateJoyStick.m_position.x * m_pcRotateScale * m_camRotateSpeed * Time.deltaTime;
						
						m_rotateVector.x += m_rotateJoyStick.m_position.y * m_pcRotateScale * m_camRotateSpeed * Time.deltaTime;
						m_rotateVector.x = Mathf.Clamp (m_rotateVector.x, m_minimumY, m_maximumY);
					}
				}
				else if (Input.GetMouseButton(0))
				{
					m_rotateVector.y = transform.localEulerAngles.y + Input.GetAxis("Mouse X") * m_pcRotateScale * m_camRotateSpeed * Time.deltaTime;
					
					m_rotateVector.x += Input.GetAxis("Mouse Y") * m_pcRotateScale * m_camRotateSpeed * Time.deltaTime;
					m_rotateVector.x = Mathf.Clamp (m_rotateVector.x, m_minimumY, m_maximumY);
				}
#endif
			}
			#endregion

			//Update moving by moving direction
			m_characterDriver.m_inputMoveDirection = transform.rotation * m_directionVector;

			//Update rotation by rotation vector.
			transform.localEulerAngles = new Vector3(-m_rotateVector.x, m_rotateVector.y, 0);

		}

	}
}

