// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using UnityEngine.UI;

namespace SIP.FastVRTools.Cameras
{
	public class Boundary
	{
		public Vector2 m_min = Vector2.zero;
		public Vector2 m_max = Vector2.zero;
	}

	[RequireComponent (typeof(Image))]
	public class ScreenJoyStick : MonoBehaviour
	{
		/// <summary>
		/// Collect all active joysticks.
		/// </summary>
		public static ScreenJoyStick[] s_joySticks;

		/// <summary>
		/// A flag to collect joysticks.
		/// </summary>
		public static bool s_enumeratedJoysticks = false;

		public static float tapTimeDelta = 0.3f;

		public bool m_isTouchPad = false;

		public bool m_enableTUIO = true;

		public Rect m_touchZone;

		public Vector2 m_deadZone = Vector2.zero;

		public bool m_normalize = false;

		/// <summary>
		/// The value of joystick between [-1, 1]
		/// </summary>
		public Vector2 m_position;

		/// <summary>
		/// Current tap count
		/// </summary>
		public int m_tapCount;

		private int m_lastfigureId = -1;

		/// <summary>
		/// How much time there is left for a tap to occur
		/// </summary>
		private float m_tapTimeWindow;

		private Vector2 m_fingerDownPos;

		private float m_fingerDownTime;

		private float m_firstDeltaTime = 0.5f;

		private Image m_gui;

		private Rect m_defaultRect;

		private Boundary m_guiBoundary = new Boundary();

		private Vector2 m_guiTouchOffset;

		private Vector2 m_guiCenter;

		void Start()
		{
			//Get the GUI texture first.
			m_gui = transform.GetComponent<Image>();

			//Get the 
			m_defaultRect = m_gui.GetPixelAdjustedRect();

			m_defaultRect.x += transform.position.x * Screen.width;
			m_defaultRect.y += transform.position.y * Screen.height;

			transform.position = Vector3.zero;

			if(m_isTouchPad)
			{
				if(m_gui.sprite.texture)
					m_touchZone = m_defaultRect;
			}
			else
			{
				//This is an offset for touch input to match with the top left corner of the GUI
				m_guiTouchOffset.x = m_defaultRect.width * 0.5f;
				m_guiTouchOffset.y = m_defaultRect.height * 0.5f;

				//Cache the center of the GUI before it change.
				m_guiCenter.x = m_defaultRect.x + m_guiTouchOffset.x;
				m_guiCenter.y = m_defaultRect.y + m_guiTouchOffset.y;

				//This it gui boundary, so we can clamp joystick movement
				m_guiBoundary.m_min.x = m_defaultRect.x - m_guiTouchOffset.x;
				m_guiBoundary.m_max.x = m_defaultRect.x + m_guiTouchOffset.x;
				m_guiBoundary.m_min.y = m_defaultRect.y - m_guiTouchOffset.y;
				m_guiBoundary.m_max.y = m_defaultRect.y + m_guiTouchOffset.y;
			}
		}

		void Disable()
		{
			gameObject.SetActive(false);
			s_enumeratedJoysticks = false;
		}

		void Update()
		{
			if(!s_enumeratedJoysticks)
			{
				//Collect all joystick in the game. so we can relay finger latching messages.
				s_joySticks = FindObjectsOfType(typeof(ScreenJoyStick)) as ScreenJoyStick[];
				s_enumeratedJoysticks = true;
			}

			if(Application.platform == RuntimePlatform.Android || Application.platform == RuntimePlatform.IPhonePlayer)
			{
				UpdateTouch();
			}
			else
			{
				if(m_enableTUIO)
					UpdateTouch();
				else
					UpdateMouse();
			}
		}

		public void UpdateMouse()
		{
			int count = 0;

			if(Input.GetMouseButton(0))
			{
				count = 1;
			}
			
			if(m_tapTimeWindow > 0)
				m_tapTimeWindow -= Time.deltaTime;
			else
				m_tapCount = 0;
			
			if(count == 0)
			{
				ResetJoystick();
			}
			else
			{
				Vector2 mousePos = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
				Vector2 guiTouchPos = mousePos - m_guiTouchOffset;

				bool shouldLatchFinger = false;
				if(m_isTouchPad)
				{
					if(m_touchZone.Contains(mousePos))
						shouldLatchFinger = true;
				}
				//else if(m_gui.HitTest(mousePos))
				//{
				//	shouldLatchFinger = true;
				//}

				if(shouldLatchFinger && (m_lastfigureId == -1))
				{
					if(m_isTouchPad)
					{
						m_fingerDownPos = mousePos;
						m_fingerDownTime = Time.time;
					}

					m_lastfigureId = 1;

					if(m_tapTimeWindow > 0)
					{
						m_tapCount ++;
					}
					else
					{
						m_tapCount = 1;
						m_tapTimeWindow = tapTimeDelta;
					}

					for(int j = 0; j < s_joySticks.Length; j++)
					{
						if(s_joySticks[j] != this)
						{
							s_joySticks[j].LatchedFinger(1);
						}
					}
				}

				if(m_lastfigureId == 1)
				{
					if(m_isTouchPad)
					{
						m_position.x = Mathf.Clamp((mousePos.x - m_fingerDownPos.x) / (m_touchZone.width / 2), -1, 1);
						m_position.y = Mathf.Clamp((mousePos.y - m_fingerDownPos.y) / (m_touchZone.height / 2), -1, 1);
					}
					else
					{
						Rect rect = m_defaultRect;
						rect.x = Mathf.Clamp(guiTouchPos.x, m_guiBoundary.m_min.x, m_guiBoundary.m_max.x);
						rect.y = Mathf.Clamp(guiTouchPos.y, m_guiBoundary.m_min.y, m_guiBoundary.m_max.y);
						//m_gui.pixelInset = rect;
					}

					if(Input.GetMouseButtonUp(0))
					{
						ResetJoystick();
					}
				}
			}
			
			if(!m_isTouchPad)
			{
				//m_position.x = (m_gui.pixelInset.x + m_guiTouchOffset.x - m_guiCenter.x) / m_guiTouchOffset.x;
				//m_position.y = (m_gui.pixelInset.y + m_guiTouchOffset.y - m_guiCenter.y) / m_guiTouchOffset.y;
			}
			
			float absoluteX = Mathf.Abs(m_position.x);
			float absoluteY = Mathf.Abs(m_position.y);
			
			if(absoluteX < m_deadZone.x)
			{
				m_position.x = 0;
			}
			else if(m_normalize)
			{
				// Rescale the output after taking the dead zone into account
				m_position.x = Mathf.Sign(m_position.x) * (absoluteX - m_deadZone.x) / (1 - m_deadZone.x);
			}
			
			if(absoluteY < m_deadZone.y)
			{
				m_position.y = 0;
			}
			else if(m_normalize)
			{
				m_position.y = Mathf.Sign(m_position.y) * (absoluteY - m_deadZone.y) / (1 - m_deadZone.y);
			}
		}

		public void UpdateTouch()
		{
			int count = 0;
			if(Application.platform == RuntimePlatform.Android || Application.platform == RuntimePlatform.IPhonePlayer)
				count = Input.touchCount;
//			else
//				count =  TuioInput.touchCount;
			
			if(m_tapTimeWindow > 0)
				m_tapTimeWindow -= Time.deltaTime;
			else
				m_tapCount = 0;
			
			if(count == 0)
			{
				ResetJoystick();
			}
			else
			{
				for(int i = 0; i < count; i++)
				{
//#if UNITY_IPHONE || UNITY_ANDROID
//
//#else
//					TuioTouch touch = TuioInput.GetTouch(i);
//#endif

					Touch touch = Input.GetTouch(i);

					Vector2 guiTouchPos = touch.position - m_guiTouchOffset;

					bool shouldLatchFinger = false;
					if(m_isTouchPad)
					{
						if(m_touchZone.Contains(touch.position))
							shouldLatchFinger = true;
					}
					//else if(m_gui.HitTest(touch.position))
					//{
					//	shouldLatchFinger = true;
					//}

					// Latch the finger if this is a new touch
					if(shouldLatchFinger && (m_lastfigureId == -1 || m_lastfigureId != touch.fingerId))
					{
						if(m_isTouchPad)
						{
							//m_gui.color.a = 0.15f;
							
							m_lastfigureId = touch.fingerId;
							m_fingerDownPos = touch.position;
							m_fingerDownTime = Time.time;
						}
						
						m_lastfigureId = touch.fingerId;
						
						if(m_tapTimeWindow > 0)
						{
							m_tapCount ++;
						}
						else
						{
							m_tapCount = 1;
							m_tapTimeWindow = tapTimeDelta;
						}
						
						for(int j = 0; j < s_joySticks.Length; j++)
						{
							if(s_joySticks[j] != this)
							{
								s_joySticks[j].LatchedFinger(touch.fingerId);
							}
						}
					}
					
					if(m_lastfigureId == touch.fingerId)
					{
						// Override the tap count with what the iPhone SDK reports if it is greater
						// This is a workaround, since the iPhone SDK does not currently track taps
						// for multiple touches
						
						if(touch.tapCount > m_tapCount)
						{
							m_tapCount = touch.tapCount;
						}
						
						if(m_isTouchPad)
						{
							m_position.x = Mathf.Clamp((touch.position.x - m_fingerDownPos.x) / (m_touchZone.width / 2), -1, 1);
							m_position.y = Mathf.Clamp((touch.position.y - m_fingerDownPos.y) / (m_touchZone.height / 2), -1, 1);
						}
						else
						{
							Rect rect = m_defaultRect;
							rect.x = Mathf.Clamp(guiTouchPos.x, m_guiBoundary.m_min.x, m_guiBoundary.m_max.x);
							rect.y = Mathf.Clamp(guiTouchPos.y, m_guiBoundary.m_min.y, m_guiBoundary.m_max.y);
							//m_gui.pixelInset = rect;
						}
//
//#if UNITY_IPHONE || UNITY_ANDROID
//						if(touch.phase == TouchPhase.Ended || touch.phase == TouchPhase.Canceled)
//						{
//							ResetJoystick();
//						}
//#else
//						if(touch.phase == TuioTouchPhase.Ended || touch.phase == TuioTouchPhase.Canceled)
//						{
//							ResetJoystick();
//						}
//#endif
						if(touch.phase == TouchPhase.Ended || touch.phase == TouchPhase.Canceled)
						{
							ResetJoystick();
						}
					}
				}
			}
			
			if(!m_isTouchPad)
			{
				//m_position.x = (m_gui.pixelInset.x + m_guiTouchOffset.x - m_guiCenter.x) / m_guiTouchOffset.x;
				//m_position.y = (m_gui.pixelInset.y + m_guiTouchOffset.y - m_guiCenter.y) / m_guiTouchOffset.y;
			}
			
			float absoluteX = Mathf.Abs(m_position.x);
			float absoluteY = Mathf.Abs(m_position.y);
			
			if(absoluteX < m_deadZone.x)
			{
				m_position.x = 0;
			}
			else if(m_normalize)
			{
				// Rescale the output after taking the dead zone into account
				m_position.x = Mathf.Sign(m_position.x) * (absoluteX - m_deadZone.x) / (1 - m_deadZone.x);
			}
			
			if(absoluteY < m_deadZone.y)
			{
				m_position.y = 0;
			}
			else if(m_normalize)
			{
				m_position.y = Mathf.Sign(m_position.y) * (absoluteY - m_deadZone.y) / (1 - m_deadZone.y);
			}
		}

		public void ResetJoystick()
		{
			// Release the finger control and set the joystick back to the default position
			//m_gui.pixelInset = m_defaultRect;
			m_lastfigureId = -1;
			m_position = Vector2.zero;
			m_fingerDownPos = Vector2.zero;

			if(m_isTouchPad)
			{
				//m_gui.color.a = 0.025;
			}
		}

		public bool IsFingerDown()
		{
			return (m_lastfigureId != -1);
		}

		public void LatchedFinger(int fingerId)
		{
			// If another joystick has latched this finger, then we must release it
			if(m_lastfigureId == fingerId)
				ResetJoystick();
		}
	}
}

